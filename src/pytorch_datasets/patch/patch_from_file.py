"""
Loads a Patch from a file - generated by the prehisto repository.

"""
from pathlib import Path
from typing import Tuple, Union

import numpy as np
from PIL import Image
import yaml


class PatchFromFile:
    """
    PatchFromFile provides a wrapper to access
    a WSI patch and its metadata from file.
    """

    def __init__(self,
                 wsi,
                 file_path: Path,
                 x_coord: int,
                 y_coord: int,
                 org_label: str = None,
                 mask_path: Path = None,
                 metadata_file: Path = None,
                 embedding: np.ndarray = None
                 ) -> None:
        """Creates a PatchFromFile

        Args:
            wsi (WSIFromFolder): WSI of the patch
            file_path (Path): File path to the WSI patch image
            x_coord (int): x-coordinate of patches in patch scale
            y_coord (int): y-coordinate of patches in patch scale
            org_label (str): The original (pre-hist) patch label
            mask_path (Path): File path to the WSI patch mask
            metadata_path (Path): File path to the WSI patch metadata
            embedding (np.ndarray): Patch embedding, optional. Default to None
        """

        self.file_path = file_path
        self.x_coord = x_coord
        self.y_coord = y_coord
        self.org_label = org_label
        
        self._prediction = None
        self.embedding = embedding
        self.wsi = wsi

        self._internal_label_set = False # track if label was "translated" to internal pytorch representation
        
        # we have to move masks back to hard drive
        self.mask_path = mask_path
        
        # if self.org_label is not None:
        #     self.wsi.wsi_dataset.patch_label_handler.add_label(self.org_label)
        # if mask is not None:
        #     self.wsi.wsi_dataset.mask_label_handler.add_labels(list(np.unique(mask)))
            
        self._load_metadata(metadata_file)
            
    def _load_metadata(self, metadata_file):
        if metadata_file is not None:
            with open(metadata_file) as metadata_f:
                # use safe_load instead load                
                metadata = yaml.safe_load(metadata_f)
            # apply on-the-fly replace of classes 
            self.label_distribution = {self.wsi.wsi_dataset.label_handler.replace_label(cls): ratio 
                                       for cls, ratio in metadata.items()}
            
            # add labels to patch label handler
            # there might be cases where labels might only be in distributions  
            #self.wsi.wsi_dataset.patch_label_handler.add_labels(list(self.label_distribution.keys()))
 
            
    def _load_mask(self):
        return np.load(self.mask_path)
           
    def get_embedding(self) -> Union[np.ndarray, None]:
        return self.embedding 
    
    def set_embedding(self, embedding) -> None:
        self.embedding = embedding
    
    def get_coordinates(self) -> Tuple[int, int]:
        return self.x_coord, self.y_coord

    def get_k_neighbours(self) -> Tuple[np.array, np.array]:
        
        neighbours, neighbour_mask = self.wsi._get_k_neighbours(self.x_coord, self.y_coord)
        
        return neighbours, neighbour_mask
    
    def get_neighbours(self, k) -> Tuple[np.array, np.array]:
        
        neighbours, neighbour_mask = self.wsi._get_neighbours(x_coord=self.x_coord, 
                                                              y_coord=self.y_coord,
                                                              k=k)
        return neighbours, neighbour_mask
    
    def get_image(self) -> Image:
        return Image.open(self.file_path)
    
    def get_context_image(self) -> Image:
        # dummy context image - we extend this later, for now the same as the patch itself
        name = self.file_path.name
        old = name.split("_")[-1]
        new_name = name.replace(old, "context_4.png")
        return Image.open(self.file_path.parent / new_name)
    
    def __call__(self):
        if self.wsi.wsi_dataset.representation == 'pixel':
            patch = Image.open(self.file_path)
        elif self.wsi.wsi_dataset.representation == 'embedding':
            patch = self.embedding
        else:
            raise Exception("Invalid representation: must be img or embedding")
     
        return patch, self.get_label(org=False)

    def get_label(self, org=False) -> int:
        if org:
            if self.wsi.wsi_dataset.patch_label_type == 'mask':
                external_label = self._load_mask()
            elif self.wsi.wsi_dataset.patch_label_type == 'patch':
                external_label = self.wsi.wsi_dataset.label_handler.translate(self.org_label)
            elif self.wsi.wsi_dataset.patch_label_type == 'img':
                external_label = self.wsi.wsi_dataset.label_handler.translate(self.wsi.wsi_label)
            elif self.wsi.wsi_dataset.patch_label_type == 'distribution':
                # list of probs [0, 0.43, 0, 0.12, 0, 0] per internal label [0, 1, 2, 3, 4, ..]
                dist_cls = self.wsi.wsi_dataset.label_handler.encode(list(self.label_distribution.keys()))
                # create a probability distribution over internal classes:
                internal_label = np.array([0 if cls not in dist_cls else 
                                  self.label_distribution[self.wsi.wsi_dataset.label_handler.classes[cls]] 
                                  for cls in self.wsi.wsi_dataset.label_handler.internal_classes])
            else:
                raise Exception("patch label type not valid")
            return external_label
        else:
            if self.wsi.wsi_dataset.patch_label_type == 'mask':
                internal_label = self.wsi.wsi_dataset.label_handler.encode(self._load_mask())
            elif self.wsi.wsi_dataset.patch_label_type == 'patch':
                internal_label = self.wsi.wsi_dataset.label_handler.encode(self.org_label)
            elif self.wsi.wsi_dataset.patch_label_type == 'img':
                internal_label = self.wsi.wsi_dataset.label_handler.encode(self.wsi.wsi_label)
            elif self.wsi.wsi_dataset.patch_label_type == 'distribution':
                # list of probs [0, 0.43, 0, 0.12, 0, 0] per internal label [0, 1, 2, 3, 4, ..]
                dist_cls = self.wsi.wsi_dataset.label_handler.encode(list(self.label_distribution.keys()))
                # create a probability distribution over internal classes:
                internal_label = np.array([0 if cls not in dist_cls else 
                                  self.label_distribution[self.wsi.wsi_dataset.label_handler.classes[cls]] 
                                  for cls in self.wsi.wsi_dataset.label_handler.internal_classes])
            else:
                raise Exception("patch label type not valid")
            return internal_label

    def set_prediction(self,
                       prediction: Tuple[float]
                       ) -> None:
        """
        Set the predictions scores

        Args:
            prediction (Tuple[float]): Prediction scores
        """
        self._prediction = prediction
    
    def has_prediction(self) -> bool:
        if self._prediction is None:
            return False
        else:
            return True    
    
    def get_prediction(self) -> Tuple[float]:
        """
        Get the prediction scores.

        Raises:
            Exception: If prediction is not set yet.

        Returns:
            Tuple[float]: Prediction scores
        """

        if self._prediction is None:
            raise Exception("Prediction not set yet. Do inference before or consider"
                            "the all_patch_mode of a wsi object")
        return self._prediction

    @staticmethod
    def parse_file(file_path: str) -> Tuple[int, int, str]:
        """
        Read the file path to extract metadata

        Args:
            file_path (str): File path of WSI patch

        Returns:
            Tuple[int, int, int]: Returns x_coord, y_coord, label
        """
        basename = Path(file_path).stem
        name_parts = basename.split('_')
        x_coord = int(name_parts[-2])
        y_coord = int(name_parts[-3])
        label = int(name_parts[-1])
        wsi_name = name_parts[-4]

        return x_coord, y_coord, label, wsi_name
    
