
from pathlib import Path
from typing import List

import numpy as np
import pandas as pd
import PIL
# "ggplot"
from plotnine import (
    aes,
    after_stat,
    ggplot,
    geom_histogram, 
    geom_bin2d, 
    xlim,
    ylim,
    scales, 
    facet_wrap, 
    labeller,
    ggsave, 
    geom_vline,
    annotate,
    theme_bw,
    coord_fixed, 
    geom_text, 
    stat_bin2d)

from src.pytorch_datasets.label_handler import LabelHandler

def plot_prob_hist(y_true,
                   y_probas,
                   label_handler,
                   log_path: str,
                   y_wsi = None,
                   true_class=1,):
    """[summary]

    Args:
        y_true ([type]): ground truth labels
        y_probas ([type]): predicted probabilities generated by sklearn classifier
        y_wsi (): wsi id of patch. will be used to group predictions per wsi
    """
    log_path = Path(log_path)
    multiclass = False 
    n_classes = len(y_probas[0])
    
    if not isinstance(y_probas[0], np.float32):
        if n_classes == 2: # plot binary prob distribution
            y_probas = [prob[true_class] for prob in y_probas]
        elif n_classes > 2: # plot multi-class prob distribution: one subplot per class
            multiclass = True
            
            y_multiclass_probas = []
            y_multiclass_true = []
            y_multiclass_pred_lbl = []
            for lbl in set(y_true):  
                y_multiclass_probas.extend([prob[lbl] for prob in y_probas])
                y_multiclass_true.extend(y_true)
                y_multiclass_pred_lbl.extend([lbl]*len(y_true))
            y_true = y_multiclass_true
            y_probas = y_multiclass_probas
        else:
            raise Exception("Cannot plot probabilities for one class prediction")

    df = pd.DataFrame(dict(true_class = [label_handler.decode(y) for y in y_true], prob = y_probas))
    df['true_class'] = pd.Categorical(df['true_class'], categories=[label_handler.decode(cls) for cls in range(n_classes)])

    if multiclass:
        df['pred_lbl']= [label_handler.decode(y) for y in y_multiclass_pred_lbl]
        df['pred_lbl'] = pd.Categorical(df['pred_lbl'], categories=[label_handler.decode(cls) for cls in range(n_classes)])

    if y_wsi is not None:
        df['wsi']=y_wsi
        hist_aes = aes(x = 'prob', fill = 'wsi')
    elif multiclass:
        hist_aes = aes(x = 'prob', fill = 'pred_lbl')
    else:        
        hist_aes = aes(x = 'prob', fill = 'true_class')
    
    p = ggplot(df, hist_aes) + geom_histogram(binwidth=0.02, alpha=0.5, position="identity", na_rm=True) + \
        xlim(-0.2,1.2) + scales.scale_fill_manual(values=label_handler.get_color_array(), type="qual")
        #scales.scale_fill_brewer(palette='Set3', type="qual", name='WSI count')

    if y_wsi is not None:
        p = p + facet_wrap('true_class', ncol=1, scales= 'fixed')

    if multiclass:
        p = p + facet_wrap('true_class', ncol=1, labeller=labeller(cols=lambda s: 'True: ' + s))

    if multiclass:
        height = 3 * n_classes
    else: # also for binary, because one plot only
        height = 3
    
    ggsave(plot = p, filename = log_path / 'tmp_hist.jpg', path = ".", verbose = False, width = 8, height = height, limitsize=False)
    image = PIL.Image.open(log_path / 'tmp_hist.jpg')
    ar = np.asarray(image)
    #conv_matrix_array = conv_matrix_array.reshape(conv_matrix_fig.canvas.get_width_height()[::-1] + (3,)) 
    ar = np.transpose(ar, (2, 0, 1)) # 3 x H x W
    return ar


def plot_score_hist(score_value: List[float],
                    score_name: str,
                    label_handler: LabelHandler,
                    log_path: str,
                    score_classes: List[int] = None) -> np.ndarray:
    """
    Generate a histogram of score values. If classes are provided, a facet histogram per class
    will be generated. Returns plot as tensorboard-compatible numpy arry (3 X H X W)


    Args:
        score_value (List[float]): [description]
        score_name (str): [description]
        label_handler (LabelHandler): [description]
        log_path (str): [description]
        score_classes (List[int], optional): [description]. Defaults to None.

    Returns:
        np.ndarray: Histogram image in array format
    """
    log_path = Path(log_path)
    if score_classes is not None:
        n_classes = len(set(score_classes))
        
    score_classes
    
    df_dict = dict()
    df_dict[score_name] = score_value
    df = pd.DataFrame(df_dict)
    if score_classes is not None:                  
        df['class'] = [label_handler.decode(cls) for cls in score_classes]
        df['class'] = pd.Categorical(df['class'], categories=[label_handler.decode(cls) for cls in range(n_classes)])

    hist_aes = aes(x = score_name)
    if score_classes is not None:        
        hist_aes = aes(x = score_name, fill = 'class')
  
    p = ggplot(df, hist_aes) + geom_histogram(binwidth=0.02, alpha=0.5, position="identity", na_rm=True) + \
        xlim(-0.2,1.2) + scales.scale_fill_manual(values=label_handler.get_color_array(type='hex'), type="qual") 
        #scales.scale_fill_brewer(palette='Set3', type="qual", name='WSI count')

    if score_classes is not None:
        p = p + facet_wrap('class', ncol=1, labeller=labeller(cols=lambda s: 'Class: ' + s))
        
        mean_score_per_class = df.groupby(['class']).mean()
        mean_score_per_class['class'] = mean_score_per_class.index
        mean_score_per_class['label'] = mean_score_per_class[score_name]
        p = p + geom_vline(aes(xintercept=score_name), data=mean_score_per_class) + \
            geom_text(aes(x=score_name, y=0, label=score_name), data=mean_score_per_class, format_string="mean-Dice: {:,.2f}")
    else:
        p = p + geom_vline(xintercept=np.mean(score_value)) + \
            annotate(geom="text", x=np.mean(score_value), y=0, label=f"mean-Dice:{str(round(np.mean(score_value), 2))}")

    if score_classes is not None:
        height = 3 * n_classes
    else: # also for binary, because one plot only
        height = 3
    
    ggsave(plot = p, filename = log_path / 'tmp_hist.jpg', path = ".", verbose = False, width = 8, height = height, limitsize=False)
    image = PIL.Image.open(log_path / 'tmp_hist.jpg')
    ar = np.asarray(image)
    ar = np.transpose(ar, (2, 0, 1)) # 3 x H x W
    return ar

def plot_score_2dhist(score_value1: List[float],
                      score_name1: str,
                      score_value2: List[float],
                      score_name2: str,
                      label_handler: LabelHandler,
                      log_path: str,
                      score_classes: List[int] = None) -> np.ndarray:
    """
    Generate a 2dehistogram of score values. If classes are provided, a facet histogram per class
    will be generated. Returns plot as tensorboard-compatible numpy arry (3 X H X W)


    Args:
        score_value1 (List[float]): [description]
        score_name1 (str): [description]
        score_value2 (List[float]): [description]
        score_name2 (str): [description]
        label_handler (LabelHandler): [description]
        log_path (str): [description]
        score_classes (List[int], optional): [description]. Defaults to None.

    Returns:
        np.ndarray: 2dHistogramm (Heatmap) image in array format
    """
    log_path = Path(log_path)
    if score_classes is not None:
        n_classes = len(set(score_classes))
        
    score_classes
    
    df_dict = dict()
    df_dict[score_name1] = [-0.1 if np.isnan(sc) else sc for sc in score_value1]
    df_dict[score_name2] = [-0.1 if np.isnan(sc) else sc for sc in score_value2] 
    df = pd.DataFrame(df_dict)

    if score_classes is not None:                  
        df['class'] = [label_handler.decode(cls) for cls in score_classes]
        df['class'] = pd.Categorical(df['class'], categories=[label_handler.decode(cls) for cls in range(n_classes)])

    hist_aes = aes(x = score_name1, y = score_name2)

    p = ggplot(df, hist_aes) +  geom_bin2d(binwidth=0.05, alpha=0.5, position="identity", na_rm=True, raster = True) \
        + xlim(-0.20,1.0) + ylim(-0.30,1.0) + scales.scale_fill_continuous(type = "viridis", name='WSI count') \
        + coord_fixed() + theme_bw() 

    if score_classes is None:
        p = p + annotate("text", x = -0.15, y = -0.08, label = "recall\nNA") + \
            annotate("text", x = -0.08, y = -0.18, label = "precision\nNA", angle = 90) 
    else:
        
        per_classes = df.groupby(['class']).mean()
        per_classes['classes'] = per_classes.index
        per_classes['x_recall'] = -0.15
        per_classes['y_recall'] = -0.08
        per_classes['text_recall'] = "recall\nNA"
        per_classes['x_precision'] = -0.08
        per_classes['y_precision'] = -0.18
        per_classes['text_precision'] = "precision\nNA"
        
        p = p + facet_wrap('class', ncol=1, labeller=labeller(cols=lambda s: 'Class: ' + s)) \
            + geom_text(aes(x='x_recall', y='y_recall', label='text_recall'), data=per_classes) \
            + geom_text(aes(x='x_precision', y='y_precision', label='text_precision'), angle = 90, data=per_classes)
        
    if score_classes is not None:
        height = 3 * n_classes
    else: # also for binary, because one plot only
        height = 3
    
    ggsave(plot = p, filename = log_path / 'tmp_hist.jpg', path = ".", verbose = False, width = 8, height = height, limitsize=False)
    image = PIL.Image.open(log_path / 'tmp_hist.jpg')
    ar = np.asarray(image)
    ar = np.transpose(ar, (2, 0, 1)) # 3 x H x W
    return ar